#![doc = include_str!("../README.md")]
// @TODO nightly?
//
// https://github.com/rust-lang/rust/issues/143874
//
// #![feature(const_trait_impl)]
#![cfg_attr(not(any(doc, test)), no_std)]
// This only refuses unsafe code in functions/expressions in this crate, but it ignores any unsafe
// code generated by this crate's macros. (https://github.com/rust-lang/nomicon/issues/506)
#![cfg_attr(not(any(doc, test)), forbid(unsafe_code))]
#![forbid(unknown_lints)]
#![forbid(unused, dead_code)]
// docs
#![forbid(missing_docs)]
// rustdoc lints: https://doc.rust-lang.org/rustdoc/lints.html
//
// rustdoc::missing_doc_code_examples we don't apply here, because it's nightly-only. Instead, we
// invoke it with `nightly` toolchain from .github/workflows/main.yml.
//
// rustdoc::invalid_codeblock_attributes we do NOT warn/deny/forbid here, even though it IS stable.
// That's because in `compile_fail` doctests we use error numbers, which are UNSTABLE only. But, to
// allow the same doctest also on stable toolchain, we ALLOW it here.
//
// See
// https://doc.rust-lang.org/rustdoc/unstable-features.html#error-numbers-for-compile-fail-doctests.
//
// But, as per that page, error numbers work on `nightly` only. On `stable` they make "code sample
// being interpreted as plain text"! So, we have those doctests in separate files, and we include
// them twice:
// - without the error code, and run as a part of standard doc generation, on `stable`. That makes
//   the doctest code formatted on `stable`.
// - with the error code, but on an element that has `#[cfg(doctest)]` attribute, so it's NOT a part
//   of doc generation, but it is still tested. That way it doesn't matter that `stable` would
//   format it as plain text, and it does get tested on `nightly` as a part of CI.
//
// Then on `nightly` we forbid rustdoc::invalid_codeblock_attributes. See
// .github/workflows/main.yml.
#![forbid(
    rustdoc::broken_intra_doc_links,
    rustdoc::private_intra_doc_links,
    rustdoc::missing_crate_level_docs,
    rustdoc::invalid_html_tags,
    rustdoc::invalid_rust_codeblocks,
    rustdoc::bare_urls,
    rustdoc::unescaped_backticks,
    rustdoc::redundant_explicit_links
)]
// doc tests
#![doc(test(attr(forbid(unused, dead_code))))]
// Workaround for https://github.com/rust-lang/rust/issues/148599
#![doc(test(attr(allow(forbidden_lint_groups))))]

#[cfg(doc)]
extern crate alloc;

// Implementation notes ARE a part of the documentation:
// - Otherwise it's a pain to edit them.
// - Users deserve documentation of how a macro works, because
//   - macros are much more difficult to read than Rust non-macro code, and
//   - macros inject code evaluated as if written by the user, so potential for a security problem,
//     even without any `unsafe` code.
//
/// Invoke an `unsafe` function.
///
/// There is **no** extra enclosing pair of parenthesis `(...)` around the list of arguments (if
/// any). If there was such a pair, it could be confused for a tuple. It would also be less readable
/// when some parameters were tuples/complex expressions.
///
/// Implementation notes
///
/// We want to accept any valid expressions for function parameters. But we don't want them to
/// evaluate inside `unsafe {...}` block that calls the given `unsafe` function. That could "hide"
/// other `unsafe` code (in expressions passed as parameters). So, we assign the given expressions
/// (for parameters) to local variables first, before `unsafe{...}`.
///
/// However, that is a challenge with `macro_rules!`:
/// - variable number of parameters => we store them in a tuple; but
/// - storing them in an ordinary "flat" tuple would involve index numbers 0, 1, 2... That is
///   difficult to generate with `macro_rules!` so that the generated numbers are literals:
///   - It is possible for `macro_rules!` to generate integer **expressions**, but even that is
///     [tricky](https://lukaswirth.dev/tlborm/decl-macros/building-blocks/counting.html).
///   - Even if we generated integer expressions, we can't use them to access tuple fields. Instead,
///     tuple access works with integer literals only.
///
/// Solution: A "tuple tree". It's an unbalanced binary tree. See it expanded:
/// - [simple_examples/fn_add_three/src/main.rs](https://github.com/peter-lyons-kehl/prudent/blob/main/simple_examples/fn_add_three/src/main.rs)
/// - `cd simple_examples/fn_add_three`
/// - `cargo expand`
///
/// // @TODO update/remove - replace with links to the stored output of `cargo expand`
/// ```rust
/// # use prudent::unsafe_fn;
/// unsafe fn add_three(left: u64, middle: u64, right: u64) -> u64 {
///     left + middle + right
/// }
/// unsafe_fn!(add_three, 1, 2, 3);
/// ```
/// expands to:
/// ```rust
/// # unsafe fn add_three(left: u64, middle: u64, right: u64) -> u64 {
/// #     left + middle + right
/// # }
/// // ...
/// {
///     let (tuple, fun) = ( (1, (2, (3,))), add_three );
///     #[allow(unsafe_code)]
///     unsafe {
///         fun(tuple.0, tuple.1 .0, tuple.1 .1 .0)
///     }
/// };
/// ```
/// and
/// [simple_examples/fn_add_four/src/main.rs](https://github.com/peter-lyons-kehl/prudent/blob/main/simple_examples/fn_add_four/src/main.rs):
/// ```rust
/// # use prudent::unsafe_fn;
/// unsafe fn add_four(left: u64, middle_left:u64, middle_right:u64, right: u64) -> u64 {
///     left + middle_left + middle_right + right
/// }
/// unsafe_fn!(add_four, 1, 2, 3, 4);
/// ```
/// expands to:
/// ```rust
/// # unsafe fn add_four(left: u64, middle_left: u64, middle_right: u64, right: u64) -> u64 {
/// #     left + middle_left + middle_right + right
/// # }
/// // ...
/// {
///     let (tuple_tree, fun) = ( (1, (2, (3, (4,)))), add_four );
///     #[allow(unsafe_code)]
///     unsafe {
///         fun(
///             tuple_tree.0,
///             tuple_tree.1 .0,
///             tuple_tree.1 .1 .0,
///             tuple_tree.1 .1 .1 .0,
///         )
///     }
/// };
/// ```
///
///  @TODO replace with examples/ :
/// ```
#[doc = include_str!("../simple_examples/fn_add_three/src/main.rs")]
/// ```
/// This does NOT accept closures, since, (as of Rust 1.91.0) closures cannot be `unsafe`.
#[macro_export]
macro_rules! unsafe_fn {
    ( $fn:expr $(, $arg:expr)* ) => {
        // Enclosed in a block, so that the result can be used as a value in an outer expression.
        {
            if false {
                let _ = $fn;
                $( let _ = $arg; )*
                unreachable!()
            } else {
                #[allow(unsafe_code)]
                unsafe {
                    $fn( $( $arg ),* )
                }
            }
        }
    };
}

/// Invoke an `unsafe` method. Like [unsafe_fn], but
/// - This accepts a receiver `&self`, `&mut self` and `self`. TODO Box/Rc/Arc, dyn?
/// - This treats `self` as if in an `unsafe {...}` block.
/// - $fn can **NOT** be an expression or a qualified path (which doesn't work in standard methods
///   calls anyways), but only an identifier.
#[macro_export]
macro_rules! unsafe_method {
    ($self:expr, $fn:ident $(, $arg:expr)* ) => {
        // Enclosed in a block, so that the result can be used as a value in an outer expression
        // without upsetting operator precedence.
        {
            if false {
                let _ = $self;
                $( let _ = $arg; )*
                unreachable!()
            } else {
                #[allow(unsafe_code)]
                unsafe { $self. $fn ( $( $arg ),* ) }
            }
        }
    };
}
//-------------

/// Set a value of a `static mut` variable or its (sub...-)field.
///
/// To minimize unintended `unsafe`, calculate any indexes etc. beforehand, store them in local
/// variables and pass them in.
///
/// We do **not** have a similar macro to get a value of a `static mut`. For that, simply enclose it
/// in `unsafe{...}`.
#[macro_export]
macro_rules! unsafe_static_set {
    ($static:expr, $val:expr) => {{
        let val = $val;
        #[allow(unsafe_code)]
        unsafe {
            $static = val;
        }
    }};
}

/// Deref a pointer (either `const` or `mut`) and yield a read-only reference.
///
/// If `$type` is given, it's expected to be the referenced type (NOT the given pointer, NOT the
/// target reference type) and the given pointer is cast to `* const $type`. `$type` may start with
/// `dyn`. `$type` may be a slice `[...]`.
#[macro_export]
macro_rules! unsafe_ref {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { &*ptr }
    }};
    ($ptr:expr, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { &*ptr as &$lifetime _ }
    }};
    ($ptr:expr, $type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as *const $type;
        unsafe { &*ptr }
    }};
    ($ptr:expr, $ptr_type:ty, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let ptr = ptr as *const $ptr_type;
        unsafe { &*ptr as &$lifetime _ }
    }};
}

/// Deref a `mut` pointer and yield a `mut` reference.
///
/// Like for [unsafe_ref]: If `$type` is given, it's expected to be the referenced type (NOT the
/// given pointer, NOT the target reference type) and the given pointer is cast to `* const $type`.
/// `$type` may start with `dyn`. `$type` may be a slice `[...]`.
#[macro_export]
macro_rules! unsafe_mut {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr }
    }};
    ($ptr:expr, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr as &$lifetime mut _}
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as *mut $ptr_type;
        // let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr}
    }};
    ($ptr:expr, $ptr_type:ty, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let ptr = ptr as *mut $ptr_type;
        //let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr as &$lifetime mut _}
    }};
}

/// This is an "early" type check for [unsafe_val], so that the user knows to use [unsafe_val] with [core::marker::Copy] types only.
///
/// NOT a part of public API!
#[doc(hidden)]
pub const fn expect_copy_ptr<T: Copy>(_: *const T) {}

/// Get a (copy of) value from where the pointer points. For [core::marker::Copy] types only.
#[macro_export]
macro_rules! unsafe_val {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        $crate::expect_copy_ptr(ptr);
        unsafe { *ptr }
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as *const $ptr_type;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        $crate::expect_copy_ptr(ptr);
        unsafe { *ptr }
    }};
}

/*
-nightly version only
https://doc.rust-lang.org/std/keyword.use.html#ergonomic-clones
https://doc.rust-lang.org/std/clone/trait.UseCloned.html


#[macro_export]
macro_rules! unsafe_use {
    ($ptr:expr) => {{
        let ptr = $ptr;
        unsafe { ( *ptr ).use }
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr as $ptr_type;
        unsafe { ( *ptr ).use }
    }};
}*/

/// Assign the given value to the location given in the pointer.
///
/// Needed, because we can't isolate:
///
/// `unsafe { *ptr } = value;`
///
/// Also, we can't have a macro invocation on the left side (target) of an assignment operator `=`,
/// so nothing like:
///
/// `unsafe_set!( pt ) = false;`
#[macro_export]
macro_rules! unsafe_set {
    ($ptr:expr, $value:expr) => {{
        let (ptr, value) = ($ptr, $value);
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        #[allow(unsafe_code)]
        unsafe {
            *ptr = value;
        }
    }};
}
