// @TODO nightly:
//
// https://github.com/rust-lang/rust/issues/143874
//
// #![feature(const_trait_impl)]
#![doc = include_str!("../README.md")]
#![cfg_attr(not(any(doc, test)), no_std)]
// This only refuses unsafe code in functions/expressions in this crate, not ones generated by this
// crate's macros.
#![cfg_attr(not(any(doc, test)), forbid(unsafe_code))]
#![forbid(unknown_lints)]
#[cfg(doc)]
extern crate alloc;

// Implementation notes ARE a part of the documentation:
// - Otherwise it's a pain to edit them.
// - Users deserve documentation of how a macro works, because
//   - macros are much more difficult to read than Rust non-macro code, and
//   - macros inject code.
//
/// Invoke an unsafe function.
///
/// There is **no** extra enclosing pair of parenthesis `(...)` around the list of arguments (if
/// any). If there was such a pair, it could be confused for a tuple. It would also be less readable
/// when some parameters were tuples/complex expressions.
///
/// Implementation notes
///
/// We want to accept any valid expressions for function parameters. But we don't want them to
/// evaluate inside `unsafe {...}` block that calls the given `unsafe` function. That could "hide"
/// other `unsafe` code (in expressions passed as parameters). So, we assign the given expressions
/// (for parameters) to local variables first, before `unsafe{...}`.
///
/// However, that is a challenge with `macro_rules!`:
/// - variable number of parameters => we store them in a tuple; but
/// - storing them in an ordinary "flat" tuple would involve index numbers 0, 1, 2... That is
///   difficult to generate with `macro_rules!` so that the generated numbers are literals. It is
///   possible for `macro_rules!` to generate integer **expressions**, but even that is
///   [tricky](https://lukaswirth.dev/tlborm/decl-macros/building-blocks/counting.html).
///
/// Instead: a "tuple tree". It's an unbalanced binary tree. See it expanded:
/// - [simple_examples/fn_add_three/src/lib.rs](https://github.com/peter-lyons-kehl/prudent/blob/main/simple_examples/fn_add_three/src/lib.rs)
/// - `cd simple_examples/fn_add_three``
/// - `cargo expand``
///
/// ```rust
/// # use prudent::unsafe_fn;
/// unsafe fn add_three(left: u64, middle: u64, right: u64) -> u64 {
///     left + middle + right
/// }
/// unsafe_fn!(add_three, 1, 2, 3);
/// ```
/// expands to:
/// ```rust
/// # use prudent::unsafe_fn;
/// # unsafe fn add_three(left: u64, middle: u64, right: u64) -> u64 {
/// #     left + middle + right
/// # }
/// // ...
/// {
///     let (tuple, fun) = ( (1, (2, (3,))), add_three );
///     #[allow(unsafe_code)]
///     unsafe {
///         fun(tuple.0, tuple.1 .0, tuple.1 .1 .0)
///     }
/// };
/// ```
/// and
/// [simple_examples/fn_add_four/src/lib.rs](https://github.com/peter-lyons-kehl/prudent/blob/main/simple_examples/fn_add_four/src/lib.rs):
/// ```rust
/// # use prudent::unsafe_fn;
/// unsafe fn add_four(left: u64, middle_left:u64, middle_right:u64, right: u64) -> u64 {
///     left + middle_left + middle_right + right
/// }
/// unsafe_fn!(add_four, 1, 2, 3, 4);
/// ```
/// expands to:
/// ```rust
/// # use prudent::unsafe_fn;
/// # unsafe fn add_four(left: u64, middle_left: u64, middle_right: u64, right: u64) -> u64 {
/// #     left + middle_left + middle_right + right
/// # }
/// // ...
/// {
///     let (tuple_tree, fun) = ( (1, (2, (3, (4,)))), add_four );
///     #[allow(unsafe_code)]
///     unsafe {
///         fun(
///             tuple_tree.0,
///             tuple_tree.1 .0,
///             tuple_tree.1 .1 .0,
///             tuple_tree.1 .1 .1 .0,
///         )
///     }
/// };
/// ```
#[macro_export]
macro_rules! unsafe_fn {
    ( $fn:expr $(, $arg:expr)+ ) => {
        // Enclosed in a block, so that
        // 1. the result can be used as a value in an outer expression, and
        // 2. local variables don't conflict with the outer scope
        {
            let (tuple_tree, fun) = ($crate::unsafe_fn_internal_build_tuple_tree!{ $($arg),+ }, $fn);

            $crate::unsafe_fn_internal_build_accessors_and_call! {
                fun,
                tuple_tree,
                ( $( $arg ),* ),
                (0)
            }
        }
    };
    ($fn:expr) => {
        {
            let fun = $fn;
            #[allow(unsafe_code)]
            unsafe {
                fun()
            }
        }
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! unsafe_fn_internal_build_tuple_tree {
    // Construct the tuple_tree. Recursive:
    ( $first:expr, $($rest:expr),+ ) => {
        (
            $first, $crate::unsafe_fn_internal_build_tuple_tree!{ $($rest),+ }
        )
    };
    ( $last:expr) => {
        ($last,)
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! unsafe_fn_internal_build_accessors_and_call {
    // Access tuple_tree parts and get ready to call the function:
    ( $fn:expr, $tuple_tree:ident,
     ( $_first_arg:expr, $($other_arg:expr),+ ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        $crate::unsafe_fn_internal_build_accessors_and_call!{
            $fn, $tuple_tree, ( $($other_arg),+ ),
            // Insert a new accessor to front (left): 0.
            (0),
            $(  // Prepend 1 to each supplied/existing accessor
                 ( 1, $($accessor_part),+ )
            ),*
        }
    };
    // All accessors are ready, so call the function:
    ( $fn:expr, $tuple_tree:ident,
      ( $_last_or_only_arg:expr ),
      $( ( $($accessor_part:tt),+
         )
      ),*
    ) => {
        #[allow(unsafe_code)]
        unsafe {
            $fn( $(
                    $crate::unsafe_fn_internal_access_tuple_tree_field!{ $tuple_tree, $($accessor_part),+ }
                ),*
            )
        }
    };
}

#[doc(hidden)]
#[macro_export]
/// INTERNAL. Do NOT use directly - subject to change.
///
/// Expand an accessor group/list to access a field in the tuple_tree.
macro_rules! unsafe_fn_internal_access_tuple_tree_field {
    ( $tuple_tree:ident, $($accessor_part:tt),* ) => {
        $tuple_tree $(. $accessor_part )*
    };
}
//-------------

// No need to seal this trait, as it's implemented for all types.
/// Trait to accept/"normalize" a given receiver `self` from `T` to `&T`, or from `T` to `&mut T`.
/// See [AsRefOrMut::prudent_normalize_value_self_as_ref].
///
/// Blanket implemented for all types.
pub trait AsRefOrMut {
    /// Serves to accept/"normalize" a given receiver `self` that is of type `T`, `&T` or `&mut T`, so that
    /// the result is always of type `&T`. That way we can store its result in a local variable,
    /// even if `self` was passed in by value (rather than by reference) without moving it.
    ///
    /// We call this method with the standard dot notation, and that's why it has such a long name,
    /// so it doesn't conflict with user-defined inherent methods or with other traits. We do NOT
    /// call this as `AsRefOrMutOrValue::prudent_normalize_value_self_as_ref(...)`, as that would
    /// require the receiver expression to be a reference (rather than allowing a value), and that's
    /// a restriction we want to prevent.
    ///
    /// Used by [unsafe_method_ref].
    fn prudent_normalize_value_self_as_ref(&self) -> &Self {
        self
    }

    /// Like [AsRefOrMut::prudent_normalize_value_self_as_ref], but this "normalizes" the given
    /// receiver to a mutable reference.
    ///
    /// Used by [unsafe_method_mut].
    fn prudent_normalize_value_self_as_mut(&mut self) -> &mut Self {
        self
    }
}
impl<T> AsRefOrMut for T {}

/// Invoke an unsafe method that has a shared reference as a receiver: `&self`.
///
/// Like [unsafe_fn], but
/// - This accepts a receiver `&self`, `&mut self` and `self` (which is then referenced, so it's
///   **not** moved/copied).
/// - This stores `self` in a variable outside of the generated `unsafe {...}`.
/// - $fn can **NOT** be an expression or a path (which doesn't work in standard methods calls), but
///   only an identifier.
#[macro_export]
macro_rules! unsafe_method_ref {
    ($self:expr, $fn:ident $(, $arg:expr)* ) => {
        //$crate::unsafe_method_internal_normalize!{ $self, () (.prudent_normalize_value_self_as_ref()) $fn $(, $arg)* }

        // const-friendly; if it creates a double reference &&, because the given expression already
        // yields a reference, that's OK. Rust will dereference it 2x.
        $crate::unsafe_method_internal_normalize!{ $self, (&) () $fn $(, $arg)* }
    }
}

/// Like [unsafe_method_ref], but for methods whose receiver is a mutable reference: `&mut self`.
#[macro_export]
macro_rules! unsafe_method_mut {
    ($self:expr, $fn:ident $(, $arg:expr)* ) => {
        // @TODO normal. prefix: &mut
        $crate::unsafe_method_internal_normalize!{ $self, () (.prudent_normalize_value_self_as_mut()) $fn $(, $arg)* }
    }
}

/// Like [unsafe_method_ref], but for methods whose receiver is passed by value: `self` (that is,
/// copied if it's [core::marker::Copy], or moved otherwise).
#[macro_export]
macro_rules! unsafe_method_val {
    ($self:expr, $fn:ident $(, $arg:expr)* ) => {
        $crate::unsafe_method_internal_normalize!{ $self, () () $fn $(, $arg)* }
    }
}

#[doc(hidden)]
#[macro_export]
/// - `$( $normalizer_suffix_part:tt )*` - an expression suffix that gets appended to $self (including any
///   leading dot, if needed). For `unsafe_method_ref` and `unsafe_method`_it "normalizes" the given
///   `$self`` to the type expected (shared reference `&self` or mutable reference `&mut`). For
///   unsafe_method_val it's empty.
macro_rules! unsafe_method_internal_normalize {
    ($self:expr, ( $( $normalizer_prefix_part:tt )* )  ( $( $normalizer_suffix_part:tt )* ) $fn:ident $(, $arg:expr)+ ) => {
        // Enclosed in a block, so that
        // 1. the result can be used as a value in an outer expression,and
        // 2. local variables don't conflict with the outer scope
        {
            use $crate::AsRefOrMut as _;
            let (tuple_tree, receiver) = (
                $crate::unsafe_fn_internal_build_tuple_tree!{ $($arg),+ },
                $( $normalizer_prefix_part )* ( $self ) $( $normalizer_suffix_part )*
            );
            $crate::unsafe_method_internal! {
                receiver,
                $fn,
                tuple_tree,
                ( $( $arg ),* ),
                (0)
            }
        }
    };

    ($self:expr, ( $( $normalizer_prefix_part:tt )* ) ( $( $normalizer_suffix_part:tt )* ) $fn:ident ) => {
        {
            use $crate::AsRefOrMut as _;
            let receiver = $( $normalizer_prefix_part )* ( $self ) $( $normalizer_suffix_part )*;
            #[allow(unsafe_code)]
            unsafe {
                receiver. $fn()
            }
        }
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! unsafe_method_internal {
    // Access tuple_tree parts and get ready to call the method:
    ( $self:expr, $fn:ident, $tuple_tree:ident,
     ( $_first_arg:expr, $($other_arg:expr),+ ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        $crate::unsafe_method_internal!{
            $self, $fn, $tuple_tree, ( $($other_arg),+ ),
            // Insert a new accessor to front (left): 0.
            (0),
            $(  // Prepend 1 to each supplied/existing accessor
                 ( 1, $($accessor_part),+ )
            ),*
        }
    };
    // All accessors are ready. $self was already evaluated (outside of unsafe {...}). So call the
    // function:
    ( $self:expr, $fn:ident, $tuple_tree:ident,
      ( $_last_or_only_arg:expr ),
      $( ( $($accessor_part:tt),+
         )
      ),*
    ) => {
        #[allow(unsafe_code)]
        unsafe {
            $self. $fn( $(
                    $crate::unsafe_fn_internal_access_tuple_tree_field!{ $tuple_tree, $($accessor_part),+ }
                ),*
            )
        }
    };
}
//-------------

/// Set a value of a `static mut` variable or its (sub...-)field.
///
/// To minimize unintended `unsafe`, calculate any indexes etc. beforehand, store them in local
/// variables and pass them in.
///
/// We do **not** have a similar macro to get a value of a `static mut`. For that, simply enclose it
/// in `unsafe{...}`.
#[macro_export]
macro_rules! unsafe_static_set {
    ($static:expr, $val:expr) => {{
        let val = $val;
        #[allow(unsafe_code)]
        unsafe {
            $static = val;
        }
    }};
}

/// Deref a pointer (either `const` or `mut`) and yield a read-only reference.
///
/// If `$type` is given, it's expected to be the referenced type (NOT the given pointer, NOT the
/// target reference type) and the given pointer is cast to `* const $type`. `$type` may start with
/// `dyn`. `$type` may be a slice `[...]`.
#[macro_export]
macro_rules! unsafe_ref {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { &*ptr }
    }};
    ($ptr:expr, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { &*ptr as &$lifetime _ }
    }};
    ($ptr:expr, $type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as *const $type;
        unsafe { &*ptr }
    }};
    ($ptr:expr, $ptr_type:ty, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let ptr = ptr as *const $ptr_type;
        unsafe { &*ptr as &$lifetime _ }
    }};
}

/// Deref a `mut` pointer and yield a `mut` reference.
///
/// Like for [unsafe_ref]: If `$type` is given, it's expected to be the referenced type (NOT the
/// given pointer, NOT the target reference type) and the given pointer is cast to `* const $type`.
/// `$type` may start with `dyn`. `$type` may be a slice `[...]`.
#[macro_export]
macro_rules! unsafe_mut {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr }
    }};
    ($ptr:expr, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr as &$lifetime mut _}
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as *mut $ptr_type;
        // let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr}
    }};
    ($ptr:expr, $ptr_type:ty, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let ptr = ptr as *mut $ptr_type;
        //let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr as &$lifetime mut _}
    }};
}

#[doc(hidden)]
/// This is an "early" type check for [unsafe_val], so that the user knows to use [unsafe_val] with [core::marker::Copy] types only.
pub const fn expect_copy_ptr<T: Copy>(_: *const T) {}

/// Get a (copy of) value from where the pointer points. For [core::marker::Copy] types only.
#[macro_export]
macro_rules! unsafe_val {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        $crate::expect_copy_ptr(ptr);
        unsafe { *ptr }
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as *const $ptr_type;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        $crate::expect_copy_ptr(ptr);
        unsafe { *ptr }
    }};
}

/*
-nightly version only
https://doc.rust-lang.org/std/keyword.use.html#ergonomic-clones
https://doc.rust-lang.org/std/clone/trait.UseCloned.html


#[macro_export]
macro_rules! unsafe_use {
    ($ptr:expr) => {{
        let ptr = $ptr;
        unsafe { ( *ptr ).use }
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr as $ptr_type;
        unsafe { ( *ptr ).use }
    }};
}*/

/// Assign the given value to the location given in the pointer.
///
/// Needed, because we can't isolate:
///
/// `unsafe { *ptr } = value;`
///
/// Also, we can't have a macro invocation on the left side (target) of an assignment operator `=`,
/// so nothing like:
///
/// `unsafe_set!( pt ) = false;`
#[macro_export]
macro_rules! unsafe_set {
    ($ptr:expr, $value:expr) => {{
        let (ptr, value) = ($ptr, $value);
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        #[allow(unsafe_code)]
        unsafe {
            *ptr = value;
        }
    }};
}
//-------------

// TODO nightly only:
//
// https://github.com/rust-lang/rust/issues/15701
//
// #![feature(stmt_expr_attributes)]
//
// (#[deny(unsafe_code)] s ).prudent_normalize_value_self_as_mut();
